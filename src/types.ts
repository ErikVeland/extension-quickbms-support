import Promise from 'bluebird';

export class QuickBMSError extends Error {
  private mErrorLines: string;
  constructor(message: string, stdErrLines: string[]) {
    super(message);
    this.name = 'QuickBMSError';

    // We probably only care for the last ~40 lines which will
    //  generally contain some sort of clue as to what actually happened.
    //  stdErr output from QBMS can be hundreds if not thousands of lines
    //  long (depending on how many mods the user had installed) which
    //  can cause the array to get truncated "<long array cut>"
    this.mErrorLines = (stdErrLines.length > 40)
      ? stdErrLines.slice(stdErrLines.length - 40).join('\n')
      : stdErrLines.join('\n');
  }

  public get errorLines(): string {
    return this.mErrorLines;
  }
}

export class UnregisteredGameError extends Error {
  constructor(gameMode: string) {
    super(`${gameMode} is not a qbms registered game`);
  }
}

export type QBMSOperationType = 'extract' | 'reimport' | 'write' | 'list';

export interface IQBMSOptions {
  // qbms will overwrite any existing files during extraction.
  overwrite?: boolean;

  // qbms verbose mode
  verbose?: boolean;

  // do we want qbms to log all of its operations
  createLog?: boolean;

  // qbms is case _in_sensitive by default
  caseSensitive?: boolean;

  // minimal information output during qbms operations (some output may still be generated)
  quiet?: boolean;

  // By default qbms will delete any temporary files generated by the .bms scripts
  //  it executes. This option ensures that qbms does not remove those automatically.
  keepTemporaryFiles?: boolean;

  // The allow resize paremeter controls QBMS's reimport process which attempts
  // to replace files within a game's archive. When set to true it will use "reimport2"
  //  and the regular "reimport" when set to false.
  //  qbms offers two reimport types, "reimport" and "reimport2";
  //  - When using the default "reimport" type it's important to ensure that
  //    the files you're using as replacements are not larger than the original files!!
  //  - Use "reimport2" if the replacement files are larger than the original files but be
  //    wary that this may be a _one_ time reimport as it may throw off any existing
  //    BMS scripts because size/offset would have changed.
  allowResize?: boolean;

  // file wildcards: both {} and * are valid, although {} is less error prone.
  wildCards?: string[];
}

export interface IListEntry {
  offset: string;
  size: string;
  filePath: string;
}

export interface IQBMSOpProps {
  // The Nexus Mods domain name for the game
  //  in question.
  gameMode: string;

  // Absolute path to the BMS script to be used
  //  for this QBMS operation.
  bmsScriptPath: string;

  // Absolute path to the affected archive
  archivePath: string;

  // QBMS specific options.
  qbmsOptions: IQBMSOptions;

  // The operation path has different uses depending
  //  on the QBMS operation we're using. e.g. qbmsExtract
  //  will extract the contents of an archive to operationPath
  //  while reimport will attempt to insert the contents of
  //  operationPath to the archive.
  operationPath?: string;

  // Extension specific attachments; should only be populated
  //  by officially supported game extensions.
  additionalAttachments?: () => Promise<IAttachmentData[]>;

  // Callback functor called once QBMS finishes its operations.
  callback?: (err: Error, data: any) => void;
}

export interface IAttachmentData {
  filePath: string;
  description: string;
}